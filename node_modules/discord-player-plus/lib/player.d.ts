import { VoiceBasedChannel } from "discord.js";
import { TypedEmitter } from "tiny-typed-emitter";
import { SearchOptions, SearchResult, Track } from "./types/engines";
import { PlayerEvents, PlayerOptions, PlayerRepeatMode, PlayOptions } from "./types/player";
export declare class Player extends TypedEmitter<PlayerEvents> {
    readonly guildId: string;
    readonly options: PlayerOptions;
    private readonly audioPlayer;
    private queue;
    private volume;
    private audioResource;
    private repeatMode;
    constructor(guildId: string, options?: PlayerOptions);
    /** Gets the next track, Considers the current repeat mode. */
    private getNextTrack;
    /**
     * Joins the given voice channel (reusing existing connection), subscribes to the audioPlayer and
     * registers events when disconnected and destroyed.
     */
    private join;
    private getEngine;
    /**
     * Immediate plays the first of the given tracks, skips current track if playing.
     * The remaining tracks will be added to the front of the queue.
     * If no tracks provided, will play first queued track if available.
     */
    play(options: PlayOptions): Promise<void>;
    /**
     * Adds the given tracks to the end of the queue. Immediately plays first track in queue if currently not playing.
     */
    add(options: PlayOptions): Promise<void>;
    /**
     * Clears queue. Does not stop current track.
     *
     * @returns Number of cleared tracks.
     */
    clear(): number;
    /**
     * Skips the current track if playing.
     *
     * @returns Skipped track, if any.
     */
    skip(): Track | undefined;
    /**
     * Pauses or resumes the current track.
     *
     * @returns `true` if paused/resumed, `false` otherwise.
     * Will be `true` if you try to pause/resume but player is already paused/resumed.
     */
    setPause(shouldPause: boolean): boolean;
    /**
     * Whether the player is currently paused.
     */
    isPaused(): boolean;
    /**
     * Whether the player is currently actively playing an audio resource.
     */
    isPlaying(): boolean;
    /**
     * Randomly shuffles the current queue.
     */
    shuffle(): void;
    /**
     * Gets the currently playing track, if any.
     */
    getCurrentTrack(): Track | undefined;
    /**
     * Gets a list of queued tracks.
     *
     * @returns Copy of the current queue.
     */
    getQueue(): Track[];
    /**
     * Sets the player volume for all tracks. Requires `inlineVolume` in player options to be `true` (default).
     *
     * @param volume Volume between 0 and 200.
     * @returns `true` if the volume was set, `false` otherwise.
     */
    setVolume(volume: number): boolean;
    /** Gets the current player volume. */
    getVolume(): number;
    /**
     * Stops the player, clears the current queue and disconnects from the voice channel if connected.
     */
    stop(): void;
    /**
     * Gets the playback duration (already played time) of the current track in milliseconds.
     */
    getPlaybackDuration(): number;
    private detectTrackSource;
    /**
     * Searches tracks for the given query.
     *
     * @returns Search result.
     */
    search(query: string, options?: SearchOptions): Promise<SearchResult[]>;
    /**
     * Seeks the current track to the given time in milliseconds.
     *
     * @returns `true` if successfully seeked, `false` otherwise.
     */
    seek(time: number): Promise<boolean>;
    /**
     * Inserts a track at a specific index. Will move current index and following after the inserted track.
     * If index is negative or grater than queue size, will insert at the start/end at the queue accordingly.
     * Will not play the track if queue is empty and currently not playing.
     */
    insert(track: Track, index: number): void;
    /**
     * Removes the queued track at the specific index, if any.
     *
     * @returns Removed track or `undefined` if index is invalid.
     */
    remove(index: number): Track | undefined;
    /** Sets the repeat mode. */
    setRepeat(mode: PlayerRepeatMode): void;
    /** Gets the current repeat mode. */
    getRepeat(): PlayerRepeatMode;
    /** Gets the voice channel that the player is currently connected to (if any). */
    getVoiceChannel(): VoiceBasedChannel | undefined;
}
//# sourceMappingURL=player.d.ts.map