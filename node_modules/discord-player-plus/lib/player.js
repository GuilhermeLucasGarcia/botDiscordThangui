"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Player = void 0;
const voice_1 = require("@discordjs/voice");
const tiny_typed_emitter_1 = require("tiny-typed-emitter");
const engines_1 = require("./engines");
const player_1 = require("./types/player");
const player_2 = require("./utils/player");
class Player extends tiny_typed_emitter_1.TypedEmitter {
    constructor(guildId, options = {}) {
        super();
        this.guildId = guildId;
        this.options = options;
        this.audioPlayer = (0, voice_1.createAudioPlayer)();
        this.queue = [];
        this.repeatMode = player_1.PlayerRepeatMode.NONE;
        this.audioPlayer.on("stateChange", (oldState, newState) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            // the following player events are based on discord voice life cycle, see: https://discordjs.guide/voice/audio-player.html#life-cycle
            const oldTrack = oldState.status !== voice_1.AudioPlayerStatus.Idle
                ? oldState.resource
                    .metadata.track
                : undefined;
            const newTrack = newState.status !== voice_1.AudioPlayerStatus.Idle
                ? newState.resource
                    .metadata.track
                : undefined;
            // check if new track has started (will also be emitted when current track has been seeked)
            if (newState.status === voice_1.AudioPlayerStatus.Playing &&
                oldState.status === voice_1.AudioPlayerStatus.Buffering &&
                newTrack) {
                this.emit("trackStart", Object.assign({}, newTrack));
            }
            // check if track has ended (will NOT be emitted when player was destroyed while playing)
            const playingTrackEnded = oldState.status === voice_1.AudioPlayerStatus.Playing &&
                ![voice_1.AudioPlayerStatus.Paused, voice_1.AudioPlayerStatus.AutoPaused].includes(newState.status);
            const pausedTrackEnded = oldState.status === voice_1.AudioPlayerStatus.Paused &&
                newState.status === voice_1.AudioPlayerStatus.Buffering;
            if (oldTrack && (playingTrackEnded || pausedTrackEnded)) {
                this.emit("trackEnd", oldTrack);
            }
            // when track ends, play next queued track if available
            if (oldState.status !== voice_1.AudioPlayerStatus.Idle &&
                newState.status === voice_1.AudioPlayerStatus.Idle) {
                const nextTrack = yield this.getNextTrack();
                if (nextTrack) {
                    const voiceChannel = oldState.resource.metadata.channel;
                    yield this.play({
                        channel: voiceChannel,
                        tracks: [nextTrack],
                    });
                }
                if (!nextTrack && ((_a = this.options.stopOnEnd) !== null && _a !== void 0 ? _a : true)) {
                    this.stop();
                }
            }
        }));
    }
    /** Gets the next track, Considers the current repeat mode. */
    getNextTrack() {
        return __awaiter(this, void 0, void 0, function* () {
            // this method is async to support autoplay and queue repeat in the future
            if (this.repeatMode === player_1.PlayerRepeatMode.TRACK) {
                const currentTrack = this.getCurrentTrack();
                if (currentTrack) {
                    delete currentTrack.seek;
                    return currentTrack;
                }
            }
            return this.queue.shift();
        });
    }
    /**
     * Joins the given voice channel (reusing existing connection), subscribes to the audioPlayer and
     * registers events when disconnected and destroyed.
     */
    join(channel) {
        var _a;
        // check if player is allowed to switch channels when already playing in another voice channel
        if (!((_a = this.options.allowSwitchChannels) !== null && _a !== void 0 ? _a : true)) {
            const currentConnection = (0, voice_1.getVoiceConnection)(channel.guildId);
            if (currentConnection &&
                currentConnection.joinConfig.channelId !== channel.id) {
                const error = new player_1.PlayerError(player_1.PlayerErrorCode.REFUSED_TO_SWITCH_VOICE_CHANNEL, `Refused to join voice channel ${channel.id} because player is already connected to voice channel ${currentConnection.joinConfig.channelId}`);
                this.emit("error", error);
                throw error;
            }
        }
        const connection = (0, voice_1.joinVoiceChannel)({
            channelId: channel.id,
            guildId: channel.guild.id,
            adapterCreator: channel.guild.voiceAdapterCreator,
        });
        // subscribing to audioPlayer allows playing music
        const subscription = connection.subscribe(this.audioPlayer);
        connection.removeAllListeners();
        connection
            .on(voice_1.VoiceConnectionStatus.Disconnected, () => __awaiter(this, void 0, void 0, function* () {
            try {
                yield Promise.race([
                    (0, voice_1.entersState)(connection, voice_1.VoiceConnectionStatus.Signalling, 5000),
                    (0, voice_1.entersState)(connection, voice_1.VoiceConnectionStatus.Connecting, 5000),
                ]);
                // seems to be reconnecting to a new channel - ignore disconnect
            }
            catch (error) {
                // seems to be a real disconnect
                connection.destroy();
            }
        }))
            .on(voice_1.VoiceConnectionStatus.Destroyed, () => {
            this.audioPlayer.stop();
            subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();
            this.audioResource = undefined;
            this.emit("destroyed");
        });
        return connection;
    }
    getEngine(source) {
        var _a;
        if ((_a = this.options.customEngines) === null || _a === void 0 ? void 0 : _a[source]) {
            return this.options.customEngines[source];
        }
        return engines_1.playerEngines[source];
    }
    /**
     * Immediate plays the first of the given tracks, skips current track if playing.
     * The remaining tracks will be added to the front of the queue.
     * If no tracks provided, will play first queued track if available.
     */
    play(options) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const track = options.tracks.length
                ? options.tracks[0]
                : this.queue.shift();
            if (!track)
                return;
            const inlineVolume = (_a = this.options.inlineVolume) !== null && _a !== void 0 ? _a : true;
            const metadata = {
                channel: options.channel,
                track,
            };
            // get playable stream for track
            // check if custom stream engine is provided
            const playerEngine = this.getEngine(track.source);
            if (!playerEngine) {
                const error = new player_1.PlayerError(player_1.PlayerErrorCode.UNKNOWN_PLAYER_ENGINE, `Unknown player engine "${track.source}"`);
                this.emit("error", error);
                throw error;
            }
            const trackStream = yield playerEngine.getStream(track, this.options);
            if (!trackStream) {
                const error = new player_1.PlayerError(player_1.PlayerErrorCode.UNKNOWN_PLAYER_ENGINE, `Unable to create stream for track (url: ${track.url})`);
                this.emit("error", error);
                throw error;
            }
            let skippedTrack;
            if (options.addSkippedTrackToQueue) {
                const track = this.getCurrentTrack();
                if (track) {
                    track.seek = this.getPlaybackDuration();
                    skippedTrack = track;
                }
            }
            // get (initial) player volume
            let volume;
            if (this.volume != null) {
                volume = this.volume;
            }
            else {
                if (typeof this.options.initialVolume === "function") {
                    try {
                        volume = yield this.options.initialVolume(options.channel.guildId);
                    }
                    catch (e) {
                        volume = 100;
                        const error = new player_1.PlayerError(player_1.PlayerErrorCode.INITIAL_VOLUME_FUNCTION_ERROR, `Unexpected error for custom initial volume function: ${e.message}`);
                        this.emit("error", error);
                    }
                }
                else {
                    volume = (_b = this.options.initialVolume) !== null && _b !== void 0 ? _b : 100;
                }
            }
            this.audioResource = (0, voice_1.createAudioResource)(trackStream.stream, {
                inputType: trackStream.type,
                inlineVolume,
                metadata,
            });
            this.setVolume(volume);
            this.join(options.channel);
            this.audioPlayer.play(this.audioResource);
            // add the rest of the tracks to the start of the queue
            this.queue.unshift(...options.tracks.slice(1));
            if (skippedTrack)
                this.queue.unshift(skippedTrack);
        });
    }
    /**
     * Adds the given tracks to the end of the queue. Immediately plays first track in queue if currently not playing.
     */
    add(options) {
        return __awaiter(this, void 0, void 0, function* () {
            this.queue.push(...options.tracks);
            if (![voice_1.AudioPlayerStatus.Buffering, voice_1.AudioPlayerStatus.Playing].includes(this.audioPlayer.state.status)) {
                yield this.play(Object.assign(Object.assign({}, options), { tracks: [] }));
            }
        });
    }
    /**
     * Clears queue. Does not stop current track.
     *
     * @returns Number of cleared tracks.
     */
    clear() {
        const length = this.queue.length;
        this.queue = [];
        return length;
    }
    /**
     * Skips the current track if playing.
     *
     * @returns Skipped track, if any.
     */
    skip() {
        const currentTrack = this.getCurrentTrack();
        const stopped = this.audioPlayer.stop();
        if (stopped)
            this.audioResource = undefined;
        return stopped ? currentTrack : undefined;
    }
    /**
     * Pauses or resumes the current track.
     *
     * @returns `true` if paused/resumed, `false` otherwise.
     * Will be `true` if you try to pause/resume but player is already paused/resumed.
     */
    setPause(shouldPause) {
        if (shouldPause && this.isPaused())
            return true;
        if (!shouldPause && this.isPlaying())
            return true;
        return shouldPause
            ? this.audioPlayer.pause(true)
            : this.audioPlayer.unpause();
    }
    /**
     * Whether the player is currently paused.
     */
    isPaused() {
        return this.audioPlayer.state.status === voice_1.AudioPlayerStatus.Paused;
    }
    /**
     * Whether the player is currently actively playing an audio resource.
     */
    isPlaying() {
        return this.audioPlayer.state.status === voice_1.AudioPlayerStatus.Playing;
    }
    /**
     * Randomly shuffles the current queue.
     */
    shuffle() {
        for (let i = this.queue.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.queue[i], this.queue[j]] = [this.queue[j], this.queue[i]];
        }
    }
    /**
     * Gets the currently playing track, if any.
     */
    getCurrentTrack() {
        if (!this.audioResource)
            return;
        return Object.assign({}, this.audioResource.metadata.track);
    }
    /**
     * Gets a list of queued tracks.
     *
     * @returns Copy of the current queue.
     */
    getQueue() {
        return this.queue.slice();
    }
    /**
     * Sets the player volume for all tracks. Requires `inlineVolume` in player options to be `true` (default).
     *
     * @param volume Volume between 0 and 200.
     * @returns `true` if the volume was set, `false` otherwise.
     */
    setVolume(volume) {
        var _a;
        if (!(0, player_2.validateVolume)(volume) || !((_a = this.audioResource) === null || _a === void 0 ? void 0 : _a.volume))
            return false;
        this.volume = volume;
        this.audioResource.volume.setVolume(volume / 100);
        return true;
    }
    /** Gets the current player volume. */
    getVolume() {
        var _a;
        return (_a = this.volume) !== null && _a !== void 0 ? _a : 100;
    }
    /**
     * Stops the player, clears the current queue and disconnects from the voice channel if connected.
     */
    stop() {
        this.clear();
        const connection = (0, voice_1.getVoiceConnection)(this.guildId);
        connection === null || connection === void 0 ? void 0 : connection.destroy();
    }
    /**
     * Gets the playback duration (already played time) of the current track in milliseconds.
     */
    getPlaybackDuration() {
        var _a, _b;
        return (_b = (_a = this.audioResource) === null || _a === void 0 ? void 0 : _a.playbackDuration) !== null && _b !== void 0 ? _b : 0;
    }
    detectTrackSource(query) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const entries = Object.entries((_a = this.options.customEngines) !== null && _a !== void 0 ? _a : {}).concat(Object.entries(engines_1.playerEngines));
            for (const [source, engine] of entries) {
                if (yield engine.isResponsible(query, this.options)) {
                    return source;
                }
            }
            return "youtube";
        });
    }
    /**
     * Searches tracks for the given query.
     *
     * @returns Search result.
     */
    search(query, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const trackSource = (options === null || options === void 0 ? void 0 : options.source) || (yield this.detectTrackSource(query));
            const playerEngine = this.getEngine(trackSource);
            if (!playerEngine)
                return [];
            return yield playerEngine.search(query, this.options, options);
        });
    }
    /**
     * Seeks the current track to the given time in milliseconds.
     *
     * @returns `true` if successfully seeked, `false` otherwise.
     */
    seek(time) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentTrack = this.getCurrentTrack();
            if (!currentTrack || !this.audioResource)
                return false;
            if (time / 1000 >= currentTrack.duration)
                return !!this.skip();
            currentTrack.seek = time > 0 ? time : 0;
            yield this.play({
                channel: this.audioResource.metadata.channel,
                tracks: [currentTrack],
            });
            return true;
        });
    }
    /**
     * Inserts a track at a specific index. Will move current index and following after the inserted track.
     * If index is negative or grater than queue size, will insert at the start/end at the queue accordingly.
     * Will not play the track if queue is empty and currently not playing.
     */
    insert(track, index) {
        if (index < 0)
            this.queue.unshift(track);
        else if (index >= this.queue.length)
            this.queue.push(track);
        else
            this.queue.splice(index, 0, track);
    }
    /**
     * Removes the queued track at the specific index, if any.
     *
     * @returns Removed track or `undefined` if index is invalid.
     */
    remove(index) {
        if (index < 0 || index >= this.queue.length)
            return;
        const removedTracks = this.queue.splice(index, 1);
        if (removedTracks.length)
            return removedTracks[0];
    }
    /** Sets the repeat mode. */
    setRepeat(mode) {
        this.repeatMode = mode;
    }
    /** Gets the current repeat mode. */
    getRepeat() {
        return this.repeatMode;
    }
    /** Gets the voice channel that the player is currently connected to (if any). */
    getVoiceChannel() {
        var _a;
        return (_a = this.audioResource) === null || _a === void 0 ? void 0 : _a.metadata.channel;
    }
}
exports.Player = Player;
//# sourceMappingURL=player.js.map